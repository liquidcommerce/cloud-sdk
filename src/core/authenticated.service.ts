import type { LIQUID_COMMERCE_ENV } from '../enums';
import type { AuthServiceResponse, IAuth } from '../types';
import type { HttpClient, IHttpClientOptions, IRequestOptions } from './utils';
import { getFetchImplementation } from './utils';

interface IAuthConfig {
  apiKey: string;

  baseURL: string;

  env: LIQUID_COMMERCE_ENV;
}

/**
 * Represents an authenticated service for making HTTP requests.
 */
export class AuthenticatedService {
  private static instance: AuthenticatedService | null = null;

  private readonly apiKey: string;

  readonly env: LIQUID_COMMERCE_ENV;

  private readonly baseURL: string;

  private accessToken: string | null = null;

  private tokenExpiration: number | null = null;

  private isAuthenticating = false;

  private readonly httpClient: HttpClient;

  private constructor(config: IAuthConfig) {
    this.apiKey = config.apiKey;
    this.env = config.env;
    this.baseURL = config.baseURL;
    this.httpClient = getFetchImplementation();
  }

  /**
   * Returns an instance of AuthenticatedClient. This method follows the singleton pattern,
   * meaning that it ensures only one instance of AuthenticatedClient is created.
   *
   * @param {IAuthConfig} config - The configuration object used to initialize the AuthenticatedClient instance.
   * @return {AuthenticatedService} An instance of AuthenticatedClient.
   */
  public static getInstance(config: IAuthConfig): AuthenticatedService {
    if (!AuthenticatedService.instance) {
      AuthenticatedService.instance = new AuthenticatedService(config);
    }

    return AuthenticatedService.instance;
  }

  /**
   * Retrieves a unique key based on the apiKey and baseURL properties.
   * The unique key is generated by concatenating the apiKey and baseURL with an underscore.
   *
   * @return {string} The unique key generated by concatenating the apiKey and baseURL.
   */
  public getUniqueKey(): string {
    return `${this.apiKey}_${this.baseURL}`;
  }

  /**
   * Authenticates the user with the LiquidCommerce API.
   *
   * This method sends a POST request to the /api/authentication endpoint,
   * and stores the received access token and token expiration time.
   *
   * @returns A Promise that resolves to void.
   * @throws An Error if the authentication fails.
   * @async
   */
  public async authenticate(): Promise<void> {
    if (this.isAuthenticating) {
      // If already authenticating, wait for it to complete
      await new Promise((resolve) => {
        const checkAuth = () => {
          if (!this.isAuthenticating) {
            resolve(undefined);
          } else {
            setTimeout(checkAuth, 100);
          }
        };

        checkAuth();
      });
      return;
    }

    this.isAuthenticating = true;
    try {
      const response = await this.requestWithoutAuth<AuthServiceResponse>('/authentication', {
        method: 'GET',
      });
      this.accessToken = response?.data?.token;
      this.tokenExpiration = response?.data?.exp;
    } catch (error) {
      console.error('Authentication failed:', error);
      throw new Error('Failed to authenticate with LiquidCommerce API');
    } finally {
      this.isAuthenticating = false;
    }
  }

  async getAuth(): Promise<IAuth> {
    const response = await this.requestWithoutAuth<AuthServiceResponse>('/authentication', {
      method: 'GET',
    });

    return response?.data;
  }

  private async requestWithoutAuth<T>(path: string, options: IRequestOptions): Promise<T> {
    const url = new URL(`api${path}`, this.baseURL);
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'X-LIQUID-API-KEY': this.apiKey,
      'X-LIQUID-API-OBF': 'true',
      ...options.headers,
    };

    const fetchOptions: IHttpClientOptions = {
      method: options.method,
      headers,
      body: options.body ? JSON.stringify(options.body) : undefined,
    };

    const response = await this.httpClient(url.toString(), fetchOptions);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return response.json();
  }

  /**
   * Checks if the token is expired.
   *
   * @returns {boolean} Returns true if the token is expired, otherwise returns false.
   */
  isTokenExpired(): boolean {
    return this.tokenExpiration ? Date.now() >= this.tokenExpiration : true;
  }

  /**
   * Sends an HTTP request to the specified path with the provided options and returns a Promise that resolves to the response data.
   *
   * @param path - The path to send the request to.
   * @param options - The options for the request, including method, headers, and body.
   * @returns A Promise that resolves to the response data.
   * @throws {Error} If the response is not successful (status is not ok).
   */
  private async request<T>(path: string, options: IRequestOptions): Promise<T> {
    try {
      if (!this.accessToken || this.isTokenExpired()) {
        await this.authenticate();
      }

      const url = new URL(`api${path}`, this.baseURL);
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        'X-LIQUID-API-KEY': this.apiKey,
        'X-LIQUID-API-OBF': 'true',
        Authorization: `Bearer ${this.accessToken}`,
        ...options.headers,
      };

      const fetchOptions: IHttpClientOptions = {
        method: options.method,
        headers,
        body: options.body ? JSON.stringify(options.body) : undefined,
      };

      const response = await this.httpClient(url.toString(), fetchOptions);

      let responseData;
      try {
        responseData = await response.json();
      } catch (error) {
        // If JSON parsing fails, try to get the text
        const text = await response.text().catch(() => `HTTP error! status: ${response.status}`);
        responseData = { message: text || error };
      }

      if (!response.ok) {
        // For error responses, create a structured error object
        const errorObj = {
          ...responseData,
          status: response.status,
          message: responseData?.message || `HTTP error! status: ${response.status}`,
        };

        throw errorObj;
      }

      return responseData;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Sends a GET request to the specified path with optional headers.
   *
   * @param {string} path - The path to send the request to.
   * @param {Record<string, string>} [headers] - Optional headers to include in the request.
   * @return {Promise<T>} - A promise that resolves to the response data.
   */
  public async get<T = any>(path: string, headers?: Record<string, string>): Promise<T> {
    return this.request<T>(path, { method: 'GET', headers });
  }

  /**
   * Sends a POST request to the specified path with optional body and headers.
   *
   * @param {string} path - The path to send the POST request to.
   * @param {any} [body] - The optional body of the request.
   * @param {Record<string, string>} [headers] - The optional headers of the request.
   *
   * @return {Promise<T>} - A Promise that resolves to the response of the request.
   *
   * @throws {Error} - If an error occurs while making the request.
   */
  public async post<T = any>(
    path: string,
    body?: any,
    headers?: Record<string, string>
  ): Promise<T> {
    return this.request<T>(path, { method: 'POST', body, headers });
  }

  /**
   * Sends a PUT request to the specified path with optional request body and headers.
   *
   * @param {string} path - The path where the PUT request will be sent.
   * @param {any} [body] - The optional body of the request.
   * @param {Record<string, string>} [headers] - The optional headers of the request.
   * @return {Promise<T>} A Promise that resolves with the response data.
   */
  public async put<T = any>(
    path: string,
    body?: any,
    headers?: Record<string, string>
  ): Promise<T> {
    return this.request<T>(path, { method: 'PUT', body, headers });
  }

  /**
   * Deletes a resource from the server using the HTTP DELETE method.
   *
   * @param path - The path of the resource to delete.
   * @param headers - Optional headers to include in the request.
   * @returns A promise that resolves to the deleted resource.
   */
  public async delete<T = any>(path: string, headers?: Record<string, string>): Promise<T> {
    return this.request<T>(path, { method: 'DELETE', headers });
  }
}
